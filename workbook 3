# Microsoft Sentinel - Advanced User Investigation Workbook
## Ghid Complet pentru Începători și Experți

### 📋 Cuprins
1. [Introducere și Concepte](#introducere)
2. [Pregătirea Mediului](#pregatirea-mediului)
3. [Structura Workbook-ului](#structura-workbook)
4. [Implementarea Pas cu Pas](#implementarea)
5. [Query-uri KQL Avansate](#query-uri-avansate)
6. [Vizualizări și Dashboards](#vizualizari)
7. [Automatizări și Alerting](#automatizari)
8. [Best Practices și Troubleshooting](#best-practices)

---

## 🚀 Introducere și Concepte {#introducere}

### Ce este acest Workbook?
Un workbook complex pentru investigarea comportamentului utilizatorilor care permite:
- **Căutarea rapidă** a utilizatorilor sau device-urilor
- **Analiza completă** a activității și locațiilor
- **Corelarea** cu alertele de securitate
- **Scoring-ul riscurilor** în timp real
- **Timeline vizual** al evenimentelor

### Beneficii:
- ⚡ Investigații mai rapide (de la ore la minute)
- 🎯 Detectarea precisă a amenințărilor
- 📊 Vizualizări interactive și intuitive
- 🔄 Automatizarea proceselor repetitive

---

## ⚙️ Pregătirea Mediului {#pregatirea-mediului}

### 1. Prerequisite
```
✓ Microsoft Sentinel workspace activ
✓ Permisiuni: Microsoft Sentinel Reader (minimum)
✓ Data Sources conectate:
  - Azure AD Sign-in Logs
  - Security Events
  - Office 365 Logs
  - Azure Activity Logs
✓ Cunoștințe de bază KQL
```

### 2. Verificarea Surselor de Date
```kql
// Verifică ce surse de date sunt disponibile
union withsource=TableName *
| where TimeGenerated > ago(1d)
| summarize Count=count() by TableName
| sort by Count desc
```

### 3. Testarea Conectivității
```kql
// Test pentru SigninLogs
SigninLogs
| where TimeGenerated > ago(1h)
| take 10

// Test pentru SecurityAlert
SecurityAlert
| where TimeGenerated > ago(24h)
| take 5
```

---

## 🏗️ Structura Workbook-ului {#structura-workbook}

### Architecture Overview
```
📊 Advanced User Investigation Workbook
├── 🔍 Section 1: User Search & Selection
├── 👤 Section 2: User Profile & Overview
├── 🖥️  Section 3: Device & Location Analysis
├── 🚨 Section 4: Security Alerts & Incidents
├── 📈 Section 5: Risk Scoring & Analytics
├── ⏰ Section 6: Timeline & Behavioral Analysis
├── 🌍 Section 7: Geo-Location Intelligence
└── 📋 Section 8: Executive Summary & Export
```

---

## 🛠️ Implementarea Pas cu Pas {#implementarea}

### Pasul 1: Crearea Workbook-ului

1. **Navigare în Sentinel**
   ```
   Azure Portal → Microsoft Sentinel → Workbooks → + New
   ```

2. **Configurarea Parametrilor Globali**
```json
{
    "UserSearchParameter": {
        "type": "text",
        "label": "🔍 Caută Utilizator",
        "defaultValue": "",
        "description": "Introdu numele utilizatorului sau email"
    },
    "TimeRangeParameter": {
        "type": "timeRange",
        "label": "📅 Interval de Timp",
        "defaultValue": "last 30 days"
    },
    "DeviceParameter": {
        "type": "dropdown",
        "label": "🖥️ Selectează Device",
        "query": "SigninLogs | distinct DeviceDetail | limit 100"
    }
}
```

### Pasul 2: Section 1 - User Search & Selection

```kql
// Query pentru căutarea utilizatorilor
let UserSearch = "{UserSearchParameter}";
let TimeRange = {TimeRangeParameter};
SigninLogs
| where TimeGenerated between (TimeRange)
| where isnotempty(UserSearch)
| where UserPrincipalName contains UserSearch 
    or DisplayName contains UserSearch
    or UserDisplayName contains UserSearch
| extend UserInfo = strcat("👤 ", UserDisplayName, " (", UserPrincipalName, ")")
| summarize 
    TotalLogins = count(),
    UniqueDevices = dcount(DeviceDetail),
    UniqueIPs = dcount(IPAddress),
    UniqueLocations = dcount(strcat(LocationDetails.city, ", ", LocationDetails.countryOrRegion)),
    FirstSeen = min(TimeGenerated),
    LastSeen = max(TimeGenerated),
    RiskEvents = countif(RiskLevelDuringSignIn != "none")
    by UserPrincipalName, UserDisplayName, UserInfo
| extend DaysActive = datetime_diff('day', LastSeen, FirstSeen)
| project-reorder UserInfo, TotalLogins, UniqueDevices, UniqueIPs, UniqueLocations, RiskEvents, DaysActive, FirstSeen, LastSeen
| sort by TotalLogins desc
```

### Pasul 3: Section 2 - User Profile & Overview

```kql
// Profil detaliat utilizator
let SelectedUser = "{SelectedUserParameter}";
let TimeRange = {TimeRangeParameter};
SigninLogs
| where TimeGenerated between (TimeRange)
| where UserPrincipalName == SelectedUser
| extend 
    GeoInfo = parse_json(LocationDetails),
    DeviceInfo = parse_json(DeviceDetail),
    AppInfo = parse_json(AppDisplayName)
| extend
    Country = tostring(GeoInfo.countryOrRegion),
    City = tostring(GeoInfo.city),
    DeviceOS = tostring(DeviceInfo.operatingSystem),
    Browser = tostring(DeviceInfo.browser)
| summarize
    // Statistici generale
    TotalSignIns = count(),
    SuccessfulSignIns = countif(ResultType == 0),
    FailedSignIns = countif(ResultType != 0),
    
    // Informații device
    UniqueDevices = dcount(DeviceId),
    PrimaryOS = take_any(DeviceOS),
    PrimaryBrowser = take_any(Browser),
    
    // Informații geografice
    Countries = make_set(Country, 10),
    Cities = make_set(City, 20),
    
    // Informații aplicații
    Applications = make_set(AppDisplayName, 15),
    
    // Informații risc
    HighRiskSignIns = countif(RiskLevelDuringSignIn == "high"),
    MediumRiskSignIns = countif(RiskLevelDuringSignIn == "medium"),
    
    // Timeline
    FirstActivity = min(TimeGenerated),
    LastActivity = max(TimeGenerated)
    
by UserPrincipalName, UserDisplayName
| extend 
    SuccessRate = round((SuccessfulSignIns * 100.0) / TotalSignIns, 2),
    RiskScore = (HighRiskSignIns * 10 + MediumRiskSignIns * 5),
    ActiveDays = datetime_diff('day', LastActivity, FirstActivity)
```

### Pasul 4: Section 3 - Device & Location Analysis

```kql
// Analiza detaliată device-uri și locații
let SelectedUser = "{SelectedUserParameter}";
let TimeRange = {TimeRangeParameter};
SigninLogs
| where TimeGenerated between (TimeRange)
| where UserPrincipalName == SelectedUser
| extend 
    GeoInfo = parse_json(LocationDetails),
    DeviceInfo = parse_json(DeviceDetail)
| extend
    Country = tostring(GeoInfo.countryOrRegion),
    State = tostring(GeoInfo.state),
    City = tostring(GeoInfo.city),
    Latitude = toreal(GeoInfo.geoCoordinates.latitude),
    Longitude = toreal(GeoInfo.geoCoordinates.longitude),
    DeviceOS = tostring(DeviceInfo.operatingSystem),
    Browser = tostring(DeviceInfo.browser),
    DeviceName = tostring(DeviceInfo.displayName)
| project 
    TimeGenerated,
    IPAddress,
    Country,
    State, 
    City,
    Latitude,
    Longitude,
    DeviceId,
    DeviceName,
    DeviceOS,
    Browser,
    AppDisplayName,
    RiskLevelDuringSignIn,
    ResultType
| extend
    Location = strcat(City, ", ", State, ", ", Country),
    DeviceInfo = strcat(DeviceName, " (", DeviceOS, " - ", Browser, ")"),
    Status = iff(ResultType == 0, "✅ Success", "❌ Failed"),
    RiskIcon = case(
        RiskLevelDuringSignIn == "high", "🔴",
        RiskLevelDuringSignIn == "medium", "🟡",
        RiskLevelDuringSignIn == "low", "🟢",
        "⚪"
    )
| project-reorder TimeGenerated, Status, RiskIcon, Location, IPAddress, DeviceInfo, AppDisplayName
| sort by TimeGenerated desc
```

### Pasul 5: Section 4 - Security Alerts & Incidents

```kql
// Corelarea cu alertele de securitate
let SelectedUser = "{SelectedUserParameter}";
let TimeRange = {TimeRangeParameter};
let UserIdentities = SigninLogs
    | where UserPrincipalName == SelectedUser
    | distinct IPAddress, DeviceId;
let UserIPs = toscalar(UserIdentities | summarize make_set(IPAddress));
let UserDevices = toscalar(UserIdentities | summarize make_set(DeviceId));
SecurityAlert
| where TimeGenerated between (TimeRange)
| where 
    Entities has SelectedUser
    or ExtendedProperties has SelectedUser
    or (Entities has_any (UserIPs))
    or (Entities has_any (UserDevices))
| extend 
    SeverityIcon = case(
        AlertSeverity == "High", "🔴",
        AlertSeverity == "Medium", "🟡",
        AlertSeverity == "Low", "🟢",
        AlertSeverity == "Informational", "🔵",
        "⚪"
    ),
    StatusIcon = case(
        Status == "New", "🆕",
        Status == "InProgress", "⏳",
        Status == "Resolved", "✅",
        Status == "Dismissed", "❌",
        "❓"
    )
| project 
    TimeGenerated,
    SeverityIcon,
    StatusIcon,
    AlertName,
    Description,
    RemediationSteps,
    CompromisedEntity,
    AttackKillChainIntent,
    Tactics,
    Techniques
| sort by TimeGenerated desc
```

### Pasul 6: Section 5 - Risk Scoring & Analytics

```kql
// Algoritm complex de risk scoring
let SelectedUser = "{SelectedUserParameter}";
let TimeRange = {TimeRangeParameter};
let BaselineData = SigninLogs
    | where TimeGenerated between (ago(90d) .. ago(30d))
    | where UserPrincipalName == SelectedUser
    | extend GeoInfo = parse_json(LocationDetails)
    | extend Country = tostring(GeoInfo.countryOrRegion)
    | summarize 
        BaselineCountries = make_set(Country),
        BaselineDevices = make_set(DeviceId),
        AvgDailyLogins = count() / 60.0;
SigninLogs
| where TimeGenerated between (TimeRange)
| where UserPrincipalName == SelectedUser
| extend 
    GeoInfo = parse_json(LocationDetails),
    DeviceInfo = parse_json(DeviceDetail)
| extend
    Country = tostring(GeoInfo.countryOrRegion),
    Hour = hourofday(TimeGenerated),
    DayOfWeek = dayofweek(TimeGenerated)
| extend BaselineData = toscalar(BaselineData | take 1)
| extend
    // Risk Factors
    NewCountryRisk = iff(Country !in (BaselineData.BaselineCountries), 25, 0),
    NewDeviceRisk = iff(DeviceId !in (BaselineData.BaselineDevices), 20, 0),
    OffHoursRisk = iff(Hour < 6 or Hour > 22, 15, 0),
    WeekendRisk = iff(DayOfWeek == 0 or DayOfWeek == 6, 10, 0),
    FailedLoginRisk = iff(ResultType != 0, 30, 0),
    HighRiskLocationRisk = case(
        RiskLevelDuringSignIn == "high", 50,
        RiskLevelDuringSignIn == "medium", 25,
        0
    )
| extend 
    TotalRiskScore = NewCountryRisk + NewDeviceRisk + OffHoursRisk + WeekendRisk + FailedLoginRisk + HighRiskLocationRisk
| extend
    RiskLevel = case(
        TotalRiskScore >= 80, "🔴 Critical",
        TotalRiskScore >= 60, "🟠 High", 
        TotalRiskScore >= 40, "🟡 Medium",
        TotalRiskScore >= 20, "🟢 Low",
        "⚪ Minimal"
    )
| project 
    TimeGenerated,
    RiskLevel,
    TotalRiskScore,
    Country,
    NewCountryRisk,
    NewDeviceRisk,
    OffHoursRisk,
    WeekendRisk,
    FailedLoginRisk,
    HighRiskLocationRisk,
    IPAddress,
    DeviceId
| sort by TotalRiskScore desc, TimeGenerated desc
```

### Pasul 7: Section 6 - Timeline & Behavioral Analysis

```kql
// Timeline comportamental avansat
let SelectedUser = "{SelectedUserParameter}";
let TimeRange = {TimeRangeParameter};
SigninLogs
| where TimeGenerated between (TimeRange)
| where UserPrincipalName == SelectedUser
| extend 
    GeoInfo = parse_json(LocationDetails),
    Hour = hourofday(TimeGenerated),
    DayOfWeek = dayofweek(TimeGenerated)
| extend
    Country = tostring(GeoInfo.countryOrRegion),
    City = tostring(GeoInfo.city)
| sort by TimeGenerated asc
| extend 
    PrevLogTime = prev(TimeGenerated),
    PrevCountry = prev(Country),
    PrevCity = prev(City)
| extend
    TimeBetweenLogins = datetime_diff('minute', TimeGenerated, PrevLogTime),
    LocationChanged = iff(Country != PrevCountry or City != PrevCity, "🌍 Location Change", "📍 Same Location"),
    ImpossibleTravel = iff(
        Country != PrevCountry and TimeBetweenLogins < 60 and isnotempty(PrevCountry), 
        "⚠️ Impossible Travel", 
        ""
    )
| extend
    ActivityPattern = case(
        Hour >= 6 and Hour <= 9, "🌅 Morning",
        Hour >= 9 and Hour <= 12, "☀️ Late Morning", 
        Hour >= 12 and Hour <= 17, "🏢 Afternoon",
        Hour >= 17 and Hour <= 22, "🌆 Evening",
        "🌙 Night"
    ),
    DayType = case(
        DayOfWeek == 1, "Monday",
        DayOfWeek == 2, "Tuesday", 
        DayOfWeek == 3, "Wednesday",
        DayOfWeek == 4, "Thursday",
        DayOfWeek == 5, "Friday",
        DayOfWeek == 6, "Saturday",
        "Sunday"
    )
| project 
    TimeGenerated,
    ActivityPattern,
    DayType,
    LocationChanged,
    ImpossibleTravel,
    Country,
    City,
    AppDisplayName,
    IPAddress,
    TimeBetweenLogins,
    ResultType
| extend Status = iff(ResultType == 0, "✅", "❌")
| project-reorder TimeGenerated, Status, ActivityPattern, LocationChanged, ImpossibleTravel, Country, City, AppDisplayName
```

### Pasul 8: Section 7 - Geo-Location Intelligence

```kql
// Inteligență geografică avansată
let SelectedUser = "{SelectedUserParameter}";
let TimeRange = {TimeRangeParameter};
SigninLogs
| where TimeGenerated between (TimeRange)
| where UserPrincipalName == SelectedUser
| extend GeoInfo = parse_json(LocationDetails)
| extend
    Country = tostring(GeoInfo.countryOrRegion),
    State = tostring(GeoInfo.state),
    City = tostring(GeoInfo.city),
    Latitude = toreal(GeoInfo.geoCoordinates.latitude),
    Longitude = toreal(GeoInfo.geoCoordinates.longitude)
| where isnotempty(Country)
| summarize 
    LoginCount = count(),
    UniqueIPs = dcount(IPAddress),
    FirstSeen = min(TimeGenerated),
    LastSeen = max(TimeGenerated),
    SuccessRate = round((countif(ResultType == 0) * 100.0) / count(), 2),
    RiskEvents = countif(RiskLevelDuringSignIn in ("high", "medium")),
    Applications = make_set(AppDisplayName, 5),
    SampleLatitude = take_any(Latitude),
    SampleLongitude = take_any(Longitude)
    by Country, State, City
| extend 
    Location = strcat(City, ", ", State, ", ", Country),
    RiskFlag = iff(RiskEvents > 0, "🚨", "✅"),
    PopularApps = strcat_array(Applications, ", ")
| project-reorder 
    RiskFlag,
    Location, 
    LoginCount, 
    UniqueIPs, 
    SuccessRate,
    RiskEvents,
    PopularApps,
    FirstSeen, 
    LastSeen,
    SampleLatitude,
    SampleLongitude
| sort by LoginCount desc
```

---

## 📊 Vizualizări și Dashboards {#vizualizari}

### 1. Configurarea Vizualizărilor

#### Harta Geografică
```json
{
    "visualization": "map",
    "settings": {
        "latitude": "SampleLatitude",
        "longitude": "SampleLongitude", 
        "size": "LoginCount",
        "color": "RiskEvents",
        "legend": {
            "isVisible": true,
            "position": "bottom"
        }
    }
}
```

#### Timeline Chart
```json
{
    "visualization": "timechart",
    "settings": {
        "xAxis": "TimeGenerated",
        "yAxes": ["LoginCount", "RiskScore"],
        "splitBy": "Country"
    }
}
```

#### Risk Heatmap
```json
{
    "visualization": "heatmap",
    "settings": {
        "xAxis": "DayOfWeek",
        "yAxis": "Hour", 
        "value": "RiskScore",
        "colorScheme": "red"
    }
}
```

### 2. Dashboard Layout

```
┌─────────────────────────────────────────────────┐
│  🔍 User Search & Quick Stats                   │
├─────────────────┬───────────────────────────────┤
│  👤 User Profile │  📊 Risk Score & Trends      │
├─────────────────┼───────────────────────────────┤
│  🌍 Geographic   │  📅 Timeline Analysis        │
│     Map          │                               │
├─────────────────┴───────────────────────────────┤
│  🚨 Security Alerts & Incidents                 │
├─────────────────────────────────────────────────┤
│  📋 Detailed Activity Log                       │
└─────────────────────────────────────────────────┘
```

---

## 🤖 Automatizări și Alerting {#automatizari}

### 1. Logica de Alerting Automată

```kql
// Alert pentru comportament suspect
let SelectedUser = "{UserPrincipalName}";
let SuspiciousActivity = SigninLogs
| where TimeGenerated > ago(1h)
| where UserPrincipalName == SelectedUser
| extend GeoInfo = parse_json(LocationDetails)
| extend Country = tostring(GeoInfo.countryOrRegion)
| summarize 
    Countries = dcount(Country),
    FailedLogins = countif(ResultType != 0),
    HighRiskLogins = countif(RiskLevelDuringSignIn == "high")
| extend AlertCondition = 
    Countries > 2 or 
    FailedLogins > 5 or 
    HighRiskLogins > 0;
SuspiciousActivity
| where AlertCondition == true
```

### 2. Webhook Integration

```json
{
    "alertRule": {
        "displayName": "Suspicious User Activity",
        "severity": "High",
        "query": "// KQL query from above",
        "actions": {
            "webhook": {
                "uri": "https://your-webhook-url.com/alert",
                "payload": {
                    "user": "{UserPrincipalName}",
                    "alertType": "SuspiciousActivity",
                    "timestamp": "{TimeGenerated}" 
                }
            }
        }
    }
}
```

---

## 🎯 Best Practices și Troubleshooting {#best-practices}

### ✅ Best Practices

#### 1. Performance Optimization
```kql
// Folosește always filtering pe timp primul
| where TimeGenerated > ago(30d)
// Apoi pe user
| where UserPrincipalName == "user@domain.com"
// Folosește summarize în loc de distinct când e posibil
| summarize count() by Country
```

#### 2. Error Handling
```kql
// Verifică dacă există date
let UserExists = toscalar(
    SigninLogs 
    | where UserPrincipalName == "{User}"
    | summarize count()
);
union (
    // Cazul cu date
    SigninLogs
    | where UserPrincipalName == "{User}" and UserExists > 0
    | // ... restul query-ului
),
(
    // Cazul fără date  
    print Message = "No data found for this user"
    | where UserExists == 0
)
```

#### 3. Resource Management
```
⚡ Limitează query-urile la ultimele 90 de zile
📊 Folosește summarize pentru agregări mari
🔄 Implementează caching pentru query-uri frecvente
📈 Monitorizează consumul de KQL compute
```

### ❌ Common Issues & Solutions

#### Issue 1: Query Timeout
```
Problem: Query-ul durează prea mult
Solution: 
- Adaugă time filters mai restrictive
- Folosește materializate views pentru date frecvente
- Împarte query-uri mari în secțiuni mai mici
```

#### Issue 2: Missing Data
```
Problem: Nu apar date pentru anumite utilizatori
Solution:
- Verifică data source connections
- Validează permisiunile pentru tabele
- Controlează time range parameters
```

#### Issue 3: Performance Issues
```
Problem: Workbook-ul se încarcă lent
Solution:
- Optimizează query-urile cu early filtering
- Folosește caching pentru parametri
- Limitează numărul de vizualizări simultane
```

### 🔧 Advanced Troubleshooting

#### Debug Mode
```kql
// Query pentru debugging
print 
    WorkbookVersion = "1.0",
    QueryTime = now(),
    UserParameter = "{UserSearchParameter}",
    TimeRange = "{TimeRangeParameter}",
    DataSources = "SigninLogs, SecurityAlert"
```

#### Performance Monitoring
```kql
// Monitorizarea performanței query-urilor
requests
| where name contains "workbook"
| summarize 
    AvgDuration = avg(duration),
    MaxDuration = max(duration),
    RequestCount = count()
    by bin(timestamp, 1h)
```

---

## 📚 Resurse Adiționale

### 🔗 Link-uri Utile
- [Microsoft Sentinel KQL Reference](https://docs.microsoft.com/azure/sentinel/kql-reference)
- [Workbook Templates Gallery](https://github.com/Azure/Azure-Sentinel/tree/master/Workbooks)
- [Best Practices Guide](https://docs.microsoft.com/azure/sentinel/best-practices-workbooks)

### 📖 Pentru Studiu Suplimentar
1. **KQL Advanced Concepts**
   - Complex joins și unions
   - Time series analysis
   - Machine learning în KQL

2. **Security Investigation Techniques** 
   - MITRE ATT&CK Framework integration
   - Threat hunting methodologies
   - Forensic timeline analysis

3. **Automation & Integration**
   - Logic Apps integration
   - Power BI connectivity
   - Custom API development

---

## 🎉 Concluzii

Acest workbook complex oferă:
- ✅ **Investigații complete** în minute în loc de ore
- ✅ **Vizualizări interactive** și intuitive  
- ✅ **Risk scoring automat** și behavioral analysis
- ✅ **Alerting inteligent** pentru amenințări
- ✅ **Scalabilitate** pentru mii de utilizatori

**Next Steps:**
1. Implementează workbook-ul pas cu pas
2. Personalizează pentru mediul tău specific
3. Adaugă propriile tale mejores și vizualizări
4. Automatizează procesele repetitive
5. Antrenează echipa în utilizarea eficientă

Succes în investigațiile tale de securitate! 🚀🔒
