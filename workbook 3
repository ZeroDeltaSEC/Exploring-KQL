# Microsoft Sentinel - Advanced User Investigation Workbook
## Ghid Complet pentru ÃncepÄƒtori È™i ExperÈ›i

### ğŸ“‹ Cuprins
1. [Introducere È™i Concepte](#introducere)
2. [PregÄƒtirea Mediului](#pregatirea-mediului)
3. [Structura Workbook-ului](#structura-workbook)
4. [Implementarea Pas cu Pas](#implementarea)
5. [Query-uri KQL Avansate](#query-uri-avansate)
6. [VizualizÄƒri È™i Dashboards](#vizualizari)
7. [AutomatizÄƒri È™i Alerting](#automatizari)
8. [Best Practices È™i Troubleshooting](#best-practices)

---

## ğŸš€ Introducere È™i Concepte {#introducere}

### Ce este acest Workbook?
Un workbook complex pentru investigarea comportamentului utilizatorilor care permite:
- **CÄƒutarea rapidÄƒ** a utilizatorilor sau device-urilor
- **Analiza completÄƒ** a activitÄƒÈ›ii È™i locaÈ›iilor
- **Corelarea** cu alertele de securitate
- **Scoring-ul riscurilor** Ã®n timp real
- **Timeline vizual** al evenimentelor

### Beneficii:
- âš¡ InvestigaÈ›ii mai rapide (de la ore la minute)
- ğŸ¯ Detectarea precisÄƒ a ameninÈ›Äƒrilor
- ğŸ“Š VizualizÄƒri interactive È™i intuitive
- ğŸ”„ Automatizarea proceselor repetitive

---

## âš™ï¸ PregÄƒtirea Mediului {#pregatirea-mediului}

### 1. Prerequisite
```
âœ“ Microsoft Sentinel workspace activ
âœ“ Permisiuni: Microsoft Sentinel Reader (minimum)
âœ“ Data Sources conectate:
  - Azure AD Sign-in Logs
  - Security Events
  - Office 365 Logs
  - Azure Activity Logs
âœ“ CunoÈ™tinÈ›e de bazÄƒ KQL
```

### 2. Verificarea Surselor de Date
```kql
// VerificÄƒ ce surse de date sunt disponibile
union withsource=TableName *
| where TimeGenerated > ago(1d)
| summarize Count=count() by TableName
| sort by Count desc
```

### 3. Testarea ConectivitÄƒÈ›ii
```kql
// Test pentru SigninLogs
SigninLogs
| where TimeGenerated > ago(1h)
| take 10

// Test pentru SecurityAlert
SecurityAlert
| where TimeGenerated > ago(24h)
| take 5
```

---

## ğŸ—ï¸ Structura Workbook-ului {#structura-workbook}

### Architecture Overview
```
ğŸ“Š Advanced User Investigation Workbook
â”œâ”€â”€ ğŸ” Section 1: User Search & Selection
â”œâ”€â”€ ğŸ‘¤ Section 2: User Profile & Overview
â”œâ”€â”€ ğŸ–¥ï¸  Section 3: Device & Location Analysis
â”œâ”€â”€ ğŸš¨ Section 4: Security Alerts & Incidents
â”œâ”€â”€ ğŸ“ˆ Section 5: Risk Scoring & Analytics
â”œâ”€â”€ â° Section 6: Timeline & Behavioral Analysis
â”œâ”€â”€ ğŸŒ Section 7: Geo-Location Intelligence
â””â”€â”€ ğŸ“‹ Section 8: Executive Summary & Export
```

---

## ğŸ› ï¸ Implementarea Pas cu Pas {#implementarea}

### Pasul 1: Crearea Workbook-ului

1. **Navigare Ã®n Sentinel**
   ```
   Azure Portal â†’ Microsoft Sentinel â†’ Workbooks â†’ + New
   ```

2. **Configurarea Parametrilor Globali**
```json
{
    "UserSearchParameter": {
        "type": "text",
        "label": "ğŸ” CautÄƒ Utilizator",
        "defaultValue": "",
        "description": "Introdu numele utilizatorului sau email"
    },
    "TimeRangeParameter": {
        "type": "timeRange",
        "label": "ğŸ“… Interval de Timp",
        "defaultValue": "last 30 days"
    },
    "DeviceParameter": {
        "type": "dropdown",
        "label": "ğŸ–¥ï¸ SelecteazÄƒ Device",
        "query": "SigninLogs | distinct DeviceDetail | limit 100"
    }
}
```

### Pasul 2: Section 1 - User Search & Selection

```kql
// Query pentru cÄƒutarea utilizatorilor
let UserSearch = "{UserSearchParameter}";
let TimeRange = {TimeRangeParameter};
SigninLogs
| where TimeGenerated between (TimeRange)
| where isnotempty(UserSearch)
| where UserPrincipalName contains UserSearch 
    or DisplayName contains UserSearch
    or UserDisplayName contains UserSearch
| extend UserInfo = strcat("ğŸ‘¤ ", UserDisplayName, " (", UserPrincipalName, ")")
| summarize 
    TotalLogins = count(),
    UniqueDevices = dcount(DeviceDetail),
    UniqueIPs = dcount(IPAddress),
    UniqueLocations = dcount(strcat(LocationDetails.city, ", ", LocationDetails.countryOrRegion)),
    FirstSeen = min(TimeGenerated),
    LastSeen = max(TimeGenerated),
    RiskEvents = countif(RiskLevelDuringSignIn != "none")
    by UserPrincipalName, UserDisplayName, UserInfo
| extend DaysActive = datetime_diff('day', LastSeen, FirstSeen)
| project-reorder UserInfo, TotalLogins, UniqueDevices, UniqueIPs, UniqueLocations, RiskEvents, DaysActive, FirstSeen, LastSeen
| sort by TotalLogins desc
```

### Pasul 3: Section 2 - User Profile & Overview

```kql
// Profil detaliat utilizator
let SelectedUser = "{SelectedUserParameter}";
let TimeRange = {TimeRangeParameter};
SigninLogs
| where TimeGenerated between (TimeRange)
| where UserPrincipalName == SelectedUser
| extend 
    GeoInfo = parse_json(LocationDetails),
    DeviceInfo = parse_json(DeviceDetail),
    AppInfo = parse_json(AppDisplayName)
| extend
    Country = tostring(GeoInfo.countryOrRegion),
    City = tostring(GeoInfo.city),
    DeviceOS = tostring(DeviceInfo.operatingSystem),
    Browser = tostring(DeviceInfo.browser)
| summarize
    // Statistici generale
    TotalSignIns = count(),
    SuccessfulSignIns = countif(ResultType == 0),
    FailedSignIns = countif(ResultType != 0),
    
    // InformaÈ›ii device
    UniqueDevices = dcount(DeviceId),
    PrimaryOS = take_any(DeviceOS),
    PrimaryBrowser = take_any(Browser),
    
    // InformaÈ›ii geografice
    Countries = make_set(Country, 10),
    Cities = make_set(City, 20),
    
    // InformaÈ›ii aplicaÈ›ii
    Applications = make_set(AppDisplayName, 15),
    
    // InformaÈ›ii risc
    HighRiskSignIns = countif(RiskLevelDuringSignIn == "high"),
    MediumRiskSignIns = countif(RiskLevelDuringSignIn == "medium"),
    
    // Timeline
    FirstActivity = min(TimeGenerated),
    LastActivity = max(TimeGenerated)
    
by UserPrincipalName, UserDisplayName
| extend 
    SuccessRate = round((SuccessfulSignIns * 100.0) / TotalSignIns, 2),
    RiskScore = (HighRiskSignIns * 10 + MediumRiskSignIns * 5),
    ActiveDays = datetime_diff('day', LastActivity, FirstActivity)
```

### Pasul 4: Section 3 - Device & Location Analysis

```kql
// Analiza detaliatÄƒ device-uri È™i locaÈ›ii
let SelectedUser = "{SelectedUserParameter}";
let TimeRange = {TimeRangeParameter};
SigninLogs
| where TimeGenerated between (TimeRange)
| where UserPrincipalName == SelectedUser
| extend 
    GeoInfo = parse_json(LocationDetails),
    DeviceInfo = parse_json(DeviceDetail)
| extend
    Country = tostring(GeoInfo.countryOrRegion),
    State = tostring(GeoInfo.state),
    City = tostring(GeoInfo.city),
    Latitude = toreal(GeoInfo.geoCoordinates.latitude),
    Longitude = toreal(GeoInfo.geoCoordinates.longitude),
    DeviceOS = tostring(DeviceInfo.operatingSystem),
    Browser = tostring(DeviceInfo.browser),
    DeviceName = tostring(DeviceInfo.displayName)
| project 
    TimeGenerated,
    IPAddress,
    Country,
    State, 
    City,
    Latitude,
    Longitude,
    DeviceId,
    DeviceName,
    DeviceOS,
    Browser,
    AppDisplayName,
    RiskLevelDuringSignIn,
    ResultType
| extend
    Location = strcat(City, ", ", State, ", ", Country),
    DeviceInfo = strcat(DeviceName, " (", DeviceOS, " - ", Browser, ")"),
    Status = iff(ResultType == 0, "âœ… Success", "âŒ Failed"),
    RiskIcon = case(
        RiskLevelDuringSignIn == "high", "ğŸ”´",
        RiskLevelDuringSignIn == "medium", "ğŸŸ¡",
        RiskLevelDuringSignIn == "low", "ğŸŸ¢",
        "âšª"
    )
| project-reorder TimeGenerated, Status, RiskIcon, Location, IPAddress, DeviceInfo, AppDisplayName
| sort by TimeGenerated desc
```

### Pasul 5: Section 4 - Security Alerts & Incidents

```kql
// Corelarea cu alertele de securitate
let SelectedUser = "{SelectedUserParameter}";
let TimeRange = {TimeRangeParameter};
let UserIdentities = SigninLogs
    | where UserPrincipalName == SelectedUser
    | distinct IPAddress, DeviceId;
let UserIPs = toscalar(UserIdentities | summarize make_set(IPAddress));
let UserDevices = toscalar(UserIdentities | summarize make_set(DeviceId));
SecurityAlert
| where TimeGenerated between (TimeRange)
| where 
    Entities has SelectedUser
    or ExtendedProperties has SelectedUser
    or (Entities has_any (UserIPs))
    or (Entities has_any (UserDevices))
| extend 
    SeverityIcon = case(
        AlertSeverity == "High", "ğŸ”´",
        AlertSeverity == "Medium", "ğŸŸ¡",
        AlertSeverity == "Low", "ğŸŸ¢",
        AlertSeverity == "Informational", "ğŸ”µ",
        "âšª"
    ),
    StatusIcon = case(
        Status == "New", "ğŸ†•",
        Status == "InProgress", "â³",
        Status == "Resolved", "âœ…",
        Status == "Dismissed", "âŒ",
        "â“"
    )
| project 
    TimeGenerated,
    SeverityIcon,
    StatusIcon,
    AlertName,
    Description,
    RemediationSteps,
    CompromisedEntity,
    AttackKillChainIntent,
    Tactics,
    Techniques
| sort by TimeGenerated desc
```

### Pasul 6: Section 5 - Risk Scoring & Analytics

```kql
// Algoritm complex de risk scoring
let SelectedUser = "{SelectedUserParameter}";
let TimeRange = {TimeRangeParameter};
let BaselineData = SigninLogs
    | where TimeGenerated between (ago(90d) .. ago(30d))
    | where UserPrincipalName == SelectedUser
    | extend GeoInfo = parse_json(LocationDetails)
    | extend Country = tostring(GeoInfo.countryOrRegion)
    | summarize 
        BaselineCountries = make_set(Country),
        BaselineDevices = make_set(DeviceId),
        AvgDailyLogins = count() / 60.0;
SigninLogs
| where TimeGenerated between (TimeRange)
| where UserPrincipalName == SelectedUser
| extend 
    GeoInfo = parse_json(LocationDetails),
    DeviceInfo = parse_json(DeviceDetail)
| extend
    Country = tostring(GeoInfo.countryOrRegion),
    Hour = hourofday(TimeGenerated),
    DayOfWeek = dayofweek(TimeGenerated)
| extend BaselineData = toscalar(BaselineData | take 1)
| extend
    // Risk Factors
    NewCountryRisk = iff(Country !in (BaselineData.BaselineCountries), 25, 0),
    NewDeviceRisk = iff(DeviceId !in (BaselineData.BaselineDevices), 20, 0),
    OffHoursRisk = iff(Hour < 6 or Hour > 22, 15, 0),
    WeekendRisk = iff(DayOfWeek == 0 or DayOfWeek == 6, 10, 0),
    FailedLoginRisk = iff(ResultType != 0, 30, 0),
    HighRiskLocationRisk = case(
        RiskLevelDuringSignIn == "high", 50,
        RiskLevelDuringSignIn == "medium", 25,
        0
    )
| extend 
    TotalRiskScore = NewCountryRisk + NewDeviceRisk + OffHoursRisk + WeekendRisk + FailedLoginRisk + HighRiskLocationRisk
| extend
    RiskLevel = case(
        TotalRiskScore >= 80, "ğŸ”´ Critical",
        TotalRiskScore >= 60, "ğŸŸ  High", 
        TotalRiskScore >= 40, "ğŸŸ¡ Medium",
        TotalRiskScore >= 20, "ğŸŸ¢ Low",
        "âšª Minimal"
    )
| project 
    TimeGenerated,
    RiskLevel,
    TotalRiskScore,
    Country,
    NewCountryRisk,
    NewDeviceRisk,
    OffHoursRisk,
    WeekendRisk,
    FailedLoginRisk,
    HighRiskLocationRisk,
    IPAddress,
    DeviceId
| sort by TotalRiskScore desc, TimeGenerated desc
```

### Pasul 7: Section 6 - Timeline & Behavioral Analysis

```kql
// Timeline comportamental avansat
let SelectedUser = "{SelectedUserParameter}";
let TimeRange = {TimeRangeParameter};
SigninLogs
| where TimeGenerated between (TimeRange)
| where UserPrincipalName == SelectedUser
| extend 
    GeoInfo = parse_json(LocationDetails),
    Hour = hourofday(TimeGenerated),
    DayOfWeek = dayofweek(TimeGenerated)
| extend
    Country = tostring(GeoInfo.countryOrRegion),
    City = tostring(GeoInfo.city)
| sort by TimeGenerated asc
| extend 
    PrevLogTime = prev(TimeGenerated),
    PrevCountry = prev(Country),
    PrevCity = prev(City)
| extend
    TimeBetweenLogins = datetime_diff('minute', TimeGenerated, PrevLogTime),
    LocationChanged = iff(Country != PrevCountry or City != PrevCity, "ğŸŒ Location Change", "ğŸ“ Same Location"),
    ImpossibleTravel = iff(
        Country != PrevCountry and TimeBetweenLogins < 60 and isnotempty(PrevCountry), 
        "âš ï¸ Impossible Travel", 
        ""
    )
| extend
    ActivityPattern = case(
        Hour >= 6 and Hour <= 9, "ğŸŒ… Morning",
        Hour >= 9 and Hour <= 12, "â˜€ï¸ Late Morning", 
        Hour >= 12 and Hour <= 17, "ğŸ¢ Afternoon",
        Hour >= 17 and Hour <= 22, "ğŸŒ† Evening",
        "ğŸŒ™ Night"
    ),
    DayType = case(
        DayOfWeek == 1, "Monday",
        DayOfWeek == 2, "Tuesday", 
        DayOfWeek == 3, "Wednesday",
        DayOfWeek == 4, "Thursday",
        DayOfWeek == 5, "Friday",
        DayOfWeek == 6, "Saturday",
        "Sunday"
    )
| project 
    TimeGenerated,
    ActivityPattern,
    DayType,
    LocationChanged,
    ImpossibleTravel,
    Country,
    City,
    AppDisplayName,
    IPAddress,
    TimeBetweenLogins,
    ResultType
| extend Status = iff(ResultType == 0, "âœ…", "âŒ")
| project-reorder TimeGenerated, Status, ActivityPattern, LocationChanged, ImpossibleTravel, Country, City, AppDisplayName
```

### Pasul 8: Section 7 - Geo-Location Intelligence

```kql
// InteligenÈ›Äƒ geograficÄƒ avansatÄƒ
let SelectedUser = "{SelectedUserParameter}";
let TimeRange = {TimeRangeParameter};
SigninLogs
| where TimeGenerated between (TimeRange)
| where UserPrincipalName == SelectedUser
| extend GeoInfo = parse_json(LocationDetails)
| extend
    Country = tostring(GeoInfo.countryOrRegion),
    State = tostring(GeoInfo.state),
    City = tostring(GeoInfo.city),
    Latitude = toreal(GeoInfo.geoCoordinates.latitude),
    Longitude = toreal(GeoInfo.geoCoordinates.longitude)
| where isnotempty(Country)
| summarize 
    LoginCount = count(),
    UniqueIPs = dcount(IPAddress),
    FirstSeen = min(TimeGenerated),
    LastSeen = max(TimeGenerated),
    SuccessRate = round((countif(ResultType == 0) * 100.0) / count(), 2),
    RiskEvents = countif(RiskLevelDuringSignIn in ("high", "medium")),
    Applications = make_set(AppDisplayName, 5),
    SampleLatitude = take_any(Latitude),
    SampleLongitude = take_any(Longitude)
    by Country, State, City
| extend 
    Location = strcat(City, ", ", State, ", ", Country),
    RiskFlag = iff(RiskEvents > 0, "ğŸš¨", "âœ…"),
    PopularApps = strcat_array(Applications, ", ")
| project-reorder 
    RiskFlag,
    Location, 
    LoginCount, 
    UniqueIPs, 
    SuccessRate,
    RiskEvents,
    PopularApps,
    FirstSeen, 
    LastSeen,
    SampleLatitude,
    SampleLongitude
| sort by LoginCount desc
```

---

## ğŸ“Š VizualizÄƒri È™i Dashboards {#vizualizari}

### 1. Configurarea VizualizÄƒrilor

#### Harta GeograficÄƒ
```json
{
    "visualization": "map",
    "settings": {
        "latitude": "SampleLatitude",
        "longitude": "SampleLongitude", 
        "size": "LoginCount",
        "color": "RiskEvents",
        "legend": {
            "isVisible": true,
            "position": "bottom"
        }
    }
}
```

#### Timeline Chart
```json
{
    "visualization": "timechart",
    "settings": {
        "xAxis": "TimeGenerated",
        "yAxes": ["LoginCount", "RiskScore"],
        "splitBy": "Country"
    }
}
```

#### Risk Heatmap
```json
{
    "visualization": "heatmap",
    "settings": {
        "xAxis": "DayOfWeek",
        "yAxis": "Hour", 
        "value": "RiskScore",
        "colorScheme": "red"
    }
}
```

### 2. Dashboard Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ” User Search & Quick Stats                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ‘¤ User Profile â”‚  ğŸ“Š Risk Score & Trends      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸŒ Geographic   â”‚  ğŸ“… Timeline Analysis        â”‚
â”‚     Map          â”‚                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸš¨ Security Alerts & Incidents                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ“‹ Detailed Activity Log                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¤– AutomatizÄƒri È™i Alerting {#automatizari}

### 1. Logica de Alerting AutomatÄƒ

```kql
// Alert pentru comportament suspect
let SelectedUser = "{UserPrincipalName}";
let SuspiciousActivity = SigninLogs
| where TimeGenerated > ago(1h)
| where UserPrincipalName == SelectedUser
| extend GeoInfo = parse_json(LocationDetails)
| extend Country = tostring(GeoInfo.countryOrRegion)
| summarize 
    Countries = dcount(Country),
    FailedLogins = countif(ResultType != 0),
    HighRiskLogins = countif(RiskLevelDuringSignIn == "high")
| extend AlertCondition = 
    Countries > 2 or 
    FailedLogins > 5 or 
    HighRiskLogins > 0;
SuspiciousActivity
| where AlertCondition == true
```

### 2. Webhook Integration

```json
{
    "alertRule": {
        "displayName": "Suspicious User Activity",
        "severity": "High",
        "query": "// KQL query from above",
        "actions": {
            "webhook": {
                "uri": "https://your-webhook-url.com/alert",
                "payload": {
                    "user": "{UserPrincipalName}",
                    "alertType": "SuspiciousActivity",
                    "timestamp": "{TimeGenerated}" 
                }
            }
        }
    }
}
```

---

## ğŸ¯ Best Practices È™i Troubleshooting {#best-practices}

### âœ… Best Practices

#### 1. Performance Optimization
```kql
// FoloseÈ™te always filtering pe timp primul
| where TimeGenerated > ago(30d)
// Apoi pe user
| where UserPrincipalName == "user@domain.com"
// FoloseÈ™te summarize Ã®n loc de distinct cÃ¢nd e posibil
| summarize count() by Country
```

#### 2. Error Handling
```kql
// VerificÄƒ dacÄƒ existÄƒ date
let UserExists = toscalar(
    SigninLogs 
    | where UserPrincipalName == "{User}"
    | summarize count()
);
union (
    // Cazul cu date
    SigninLogs
    | where UserPrincipalName == "{User}" and UserExists > 0
    | // ... restul query-ului
),
(
    // Cazul fÄƒrÄƒ date  
    print Message = "No data found for this user"
    | where UserExists == 0
)
```

#### 3. Resource Management
```
âš¡ LimiteazÄƒ query-urile la ultimele 90 de zile
ğŸ“Š FoloseÈ™te summarize pentru agregÄƒri mari
ğŸ”„ ImplementeazÄƒ caching pentru query-uri frecvente
ğŸ“ˆ MonitorizeazÄƒ consumul de KQL compute
```

### âŒ Common Issues & Solutions

#### Issue 1: Query Timeout
```
Problem: Query-ul dureazÄƒ prea mult
Solution: 
- AdaugÄƒ time filters mai restrictive
- FoloseÈ™te materializate views pentru date frecvente
- Ãmparte query-uri mari Ã®n secÈ›iuni mai mici
```

#### Issue 2: Missing Data
```
Problem: Nu apar date pentru anumite utilizatori
Solution:
- VerificÄƒ data source connections
- ValideazÄƒ permisiunile pentru tabele
- ControleazÄƒ time range parameters
```

#### Issue 3: Performance Issues
```
Problem: Workbook-ul se Ã®ncarcÄƒ lent
Solution:
- OptimizeazÄƒ query-urile cu early filtering
- FoloseÈ™te caching pentru parametri
- LimiteazÄƒ numÄƒrul de vizualizÄƒri simultane
```

### ğŸ”§ Advanced Troubleshooting

#### Debug Mode
```kql
// Query pentru debugging
print 
    WorkbookVersion = "1.0",
    QueryTime = now(),
    UserParameter = "{UserSearchParameter}",
    TimeRange = "{TimeRangeParameter}",
    DataSources = "SigninLogs, SecurityAlert"
```

#### Performance Monitoring
```kql
// Monitorizarea performanÈ›ei query-urilor
requests
| where name contains "workbook"
| summarize 
    AvgDuration = avg(duration),
    MaxDuration = max(duration),
    RequestCount = count()
    by bin(timestamp, 1h)
```

---

## ğŸ“š Resurse AdiÈ›ionale

### ğŸ”— Link-uri Utile
- [Microsoft Sentinel KQL Reference](https://docs.microsoft.com/azure/sentinel/kql-reference)
- [Workbook Templates Gallery](https://github.com/Azure/Azure-Sentinel/tree/master/Workbooks)
- [Best Practices Guide](https://docs.microsoft.com/azure/sentinel/best-practices-workbooks)

### ğŸ“– Pentru Studiu Suplimentar
1. **KQL Advanced Concepts**
   - Complex joins È™i unions
   - Time series analysis
   - Machine learning Ã®n KQL

2. **Security Investigation Techniques** 
   - MITRE ATT&CK Framework integration
   - Threat hunting methodologies
   - Forensic timeline analysis

3. **Automation & Integration**
   - Logic Apps integration
   - Power BI connectivity
   - Custom API development

---

## ğŸ‰ Concluzii

Acest workbook complex oferÄƒ:
- âœ… **InvestigaÈ›ii complete** Ã®n minute Ã®n loc de ore
- âœ… **VizualizÄƒri interactive** È™i intuitive  
- âœ… **Risk scoring automat** È™i behavioral analysis
- âœ… **Alerting inteligent** pentru ameninÈ›Äƒri
- âœ… **Scalabilitate** pentru mii de utilizatori

**Next Steps:**
1. ImplementeazÄƒ workbook-ul pas cu pas
2. PersonalizeazÄƒ pentru mediul tÄƒu specific
3. AdaugÄƒ propriile tale mejores È™i vizualizÄƒri
4. AutomatizeazÄƒ procesele repetitive
5. AntreneazÄƒ echipa Ã®n utilizarea eficientÄƒ

Succes Ã®n investigaÈ›iile tale de securitate! ğŸš€ğŸ”’
